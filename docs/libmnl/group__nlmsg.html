<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmnl: Netlink message helpers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmnl
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Netlink message helpers</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa6cdcdd6af1bab1ec4031faf97b18af7"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#gaa6cdcdd6af1bab1ec4031faf97b18af7">mnl_nlmsg_size</a> (size_t len)</td></tr>
<tr class="separator:gaa6cdcdd6af1bab1ec4031faf97b18af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa7fddde3ccd67120a1522407413060"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga6fa7fddde3ccd67120a1522407413060">mnl_nlmsg_get_payload_len</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh)</td></tr>
<tr class="separator:ga6fa7fddde3ccd67120a1522407413060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead09f5a9430a226b1ca86ad1f36d316"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#gaead09f5a9430a226b1ca86ad1f36d316">mnl_nlmsg_put_header</a> (void *buf)</td></tr>
<tr class="separator:gaead09f5a9430a226b1ca86ad1f36d316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01decfe8875435fe290bccdb83c049e1"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga01decfe8875435fe290bccdb83c049e1">mnl_nlmsg_put_extra_header</a> (struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, size_t size)</td></tr>
<tr class="separator:ga01decfe8875435fe290bccdb83c049e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432cc083f224c34bac8455e79750d253"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga432cc083f224c34bac8455e79750d253">mnl_nlmsg_get_payload</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh)</td></tr>
<tr class="separator:ga432cc083f224c34bac8455e79750d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6428fd8f5a7ef3833d82e529fb127994"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga6428fd8f5a7ef3833d82e529fb127994">mnl_nlmsg_get_payload_offset</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, size_t offset)</td></tr>
<tr class="separator:ga6428fd8f5a7ef3833d82e529fb127994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48940153e49c7cd698689e5c00f3566"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#gaa48940153e49c7cd698689e5c00f3566">mnl_nlmsg_ok</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, int len)</td></tr>
<tr class="separator:gaa48940153e49c7cd698689e5c00f3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81912a38a495d5d82026ef0afd142e2"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#gaa81912a38a495d5d82026ef0afd142e2">mnl_nlmsg_next</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, int *len)</td></tr>
<tr class="separator:gaa81912a38a495d5d82026ef0afd142e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2a37653518b5d9e82b4ab41c7025f4"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#gaae2a37653518b5d9e82b4ab41c7025f4">mnl_nlmsg_get_payload_tail</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh)</td></tr>
<tr class="separator:gaae2a37653518b5d9e82b4ab41c7025f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c95a2455127da992641de0679dbab46"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga2c95a2455127da992641de0679dbab46">mnl_nlmsg_seq_ok</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, unsigned int seq)</td></tr>
<tr class="separator:ga2c95a2455127da992641de0679dbab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e909f59f090f2d97a6a935c6b0c656e"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga0e909f59f090f2d97a6a935c6b0c656e">mnl_nlmsg_portid_ok</a> (const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *nlh, unsigned int portid)</td></tr>
<tr class="separator:ga0e909f59f090f2d97a6a935c6b0c656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568a82daad5244760de126574367ef84"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nlmsg.html#ga568a82daad5244760de126574367ef84">mnl_nlmsg_fprintf</a> (FILE *fd, const void *data, size_t datalen, size_t extra_header_size)</td></tr>
<tr class="separator:ga568a82daad5244760de126574367ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Netlink message: </p><pre class="fragment">    |&lt;----------------- 4 bytes -------------------&gt;|
    |&lt;----- 2 bytes ------&gt;|&lt;------- 2 bytes ------&gt;|
    |-----------------------------------------------|
    |      Message length (including header)        |
    |-----------------------------------------------|
    |     Message type     |     Message flags      |
    |-----------------------------------------------|
    |           Message sequence number             |
    |-----------------------------------------------|
    |                 Netlink PortID                |
    |-----------------------------------------------|
    |                                               |
    .                   Payload                     .
    |_______________________________________________|
</pre><p>There is usually an extra header after the the Netlink header (at the beginning of the payload). This extra header is specific of the Netlink subsystem. After this extra header, it comes the sequence of attributes that are expressed in Type-Length-Value (TLV) format. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga568a82daad5244760de126574367ef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568a82daad5244760de126574367ef84">&#9670;&nbsp;</a></span>mnl_nlmsg_fprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL void mnl_nlmsg_fprintf </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>extra_header_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_fprintf - print netlink message to file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>pointer to file type </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the buffer that contains messages to be printed </td></tr>
    <tr><td class="paramname">datalen</td><td>length of data stored in the buffer </td></tr>
    <tr><td class="paramname">extra_header_size</td><td>size of the extra header (if any)</td></tr>
  </table>
  </dd>
</dl>
<p>This function prints the netlink header to a file handle. It may be useful for debugging purposes. One example of the output is the following:</p>
<pre class="fragment">----------------        ------------------
|  0000000040  |        | message length |
| 00016 | R-A- |        |  type | flags  |
|  1289148991  |        | sequence number|
|  0000000000  |        |     port ID    |
----------------        ------------------
| 00 00 00 00  |        |  extra header  |
| 00 00 00 00  |        |  extra header  |
| 01 00 00 00  |        |  extra header  |
| 01 00 00 00  |        |  extra header  |
|00008|--|00003|        |len |flags| type|
| 65 74 68 30  |        |      data      |       e t h 0
----------------        ------------------
</pre><p>This example above shows the netlink message that is send to kernel-space to set up the link interface eth0. The netlink and attribute header data are displayed in base 10 whereas the extra header and the attribute payload are expressed in base 16. The possible flags in the netlink header are:</p>
<ul>
<li>R, that indicates that NLM_F_REQUEST is set.</li>
<li>M, that indicates that NLM_F_MULTI is set.</li>
<li>A, that indicates that NLM_F_ACK is set.</li>
<li>E, that indicates that NLM_F_ECHO is set.</li>
</ul>
<p>The lack of one flag is displayed with '-'. On the other hand, the possible attribute flags available are:</p>
<ul>
<li>N, that indicates that NLA_F_NESTED is set.</li>
<li>B, that indicates that NLA_F_NET_BYTEORDER is set. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00360">360</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

<p class="reference">References <a class="el" href="nlmsg_8c_source.html#l00152">mnl_nlmsg_ok()</a>.</p>

</div>
</div>
<a id="ga432cc083f224c34bac8455e79750d253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432cc083f224c34bac8455e79750d253">&#9670;&nbsp;</a></span>mnl_nlmsg_get_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL void* mnl_nlmsg_get_payload </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_get_payload - get a pointer to the payload of the netlink message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>pointer to a netlink header</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a pointer to the payload of the netlink message. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00117">117</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="ga6fa7fddde3ccd67120a1522407413060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fa7fddde3ccd67120a1522407413060">&#9670;&nbsp;</a></span>mnl_nlmsg_get_payload_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL size_t mnl_nlmsg_get_payload_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_get_payload_len - get the length of the Netlink payload </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>pointer to the header of the Netlink message</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Length of the netlink payload, ie. the length of the full message minus the size of the Netlink header. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00066">66</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="ga6428fd8f5a7ef3833d82e529fb127994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6428fd8f5a7ef3833d82e529fb127994">&#9670;&nbsp;</a></span>mnl_nlmsg_get_payload_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL void* mnl_nlmsg_get_payload_offset </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_get_payload_offset - get a pointer to the payload of the message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>pointer to a netlink header </td></tr>
    <tr><td class="paramname">offset</td><td>offset to the payload of the attributes TLV set</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a pointer to the payload of the netlink message plus a given offset. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00130">130</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="gaae2a37653518b5d9e82b4ab41c7025f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae2a37653518b5d9e82b4ab41c7025f4">&#9670;&nbsp;</a></span>mnl_nlmsg_get_payload_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL void* mnl_nlmsg_get_payload_tail </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_get_payload_tail - get the ending of the netlink message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>pointer to netlink message</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a pointer to the netlink message tail. This is useful to build a message since we continue adding attributes at the end of the message. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00187">187</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="attr_8c_source.html#l00714">mnl_attr_nest_cancel()</a>, <a class="el" href="attr_8c_source.html#l00701">mnl_attr_nest_end()</a>, <a class="el" href="attr_8c_source.html#l00514">mnl_attr_nest_start()</a>, and <a class="el" href="attr_8c_source.html#l00395">mnl_attr_put()</a>.</p>

</div>
</div>
<a id="gaa81912a38a495d5d82026ef0afd142e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa81912a38a495d5d82026ef0afd142e2">&#9670;&nbsp;</a></span>mnl_nlmsg_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a>* mnl_nlmsg_next </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_next - get the next netlink message in a multipart message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>current netlink message that we are handling </td></tr>
    <tr><td class="paramname">len</td><td>length of the remaining bytes in the buffer (passed by reference).</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a pointer to the next netlink message that is part of a multi-part netlink message. Netlink can batch several messages into one buffer so that the receiver has to iterate over the whole set of Netlink messages.</p>
<p>You have to use <a class="el" href="group__nlmsg.html#gaa48940153e49c7cd698689e5c00f3566">mnl_nlmsg_ok()</a> to check if the next Netlink message is valid. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00172">172</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="gaa48940153e49c7cd698689e5c00f3566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa48940153e49c7cd698689e5c00f3566">&#9670;&nbsp;</a></span>mnl_nlmsg_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL bool mnl_nlmsg_ok </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_ok - check a there is room for netlink message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>netlink message that we want to check </td></tr>
    <tr><td class="paramname">len</td><td>remaining bytes in a buffer that contains the netlink message</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to check that a buffer that contains a netlink message has enough room for the netlink message that it stores, ie. this function can be used to verify that a netlink message is not malformed nor truncated.</p>
<p>This function does not set errno in case of error since it is intended for iterations. Thus, it returns true on success and false on error.</p>
<p>The len parameter may become negative in malformed messages during message iteration, that is why we use a signed integer. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00152">152</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="nlmsg_8c_source.html#l00360">mnl_nlmsg_fprintf()</a>.</p>

</div>
</div>
<a id="ga0e909f59f090f2d97a6a935c6b0c656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e909f59f090f2d97a6a935c6b0c656e">&#9670;&nbsp;</a></span>mnl_nlmsg_portid_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL bool mnl_nlmsg_portid_ok </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>portid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_portid_ok - perform portID origin check </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>current netlink message that we are handling </td></tr>
    <tr><td class="paramname">portid</td><td>netlink portid that we want to check</td></tr>
  </table>
  </dd>
</dl>
<p>This functions returns true if the origin is fulfilled, otherwise false is returned. We skip the tracking for netlink message whose portID is zero since it is reserved for event-based kernel notifications. On the other hand, if portid is set but the message PortID is not (i.e. this is an event message coming from kernel-space), then we also skip the tracking. This approach is good if we use the same socket to send commands to kernel-space (that we want to track) and to listen to events (that we do not track). </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00226">226</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="ga01decfe8875435fe290bccdb83c049e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01decfe8875435fe290bccdb83c049e1">&#9670;&nbsp;</a></span>mnl_nlmsg_put_extra_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL void* mnl_nlmsg_put_extra_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_put_extra_header - reserve and prepare room for an extra header </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>pointer to Netlink header </td></tr>
    <tr><td class="paramname">size</td><td>size of the extra header that we want to put</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets to zero the room that is required to put the extra header after the initial Netlink header. This function also increases the nlmsg_len field. You have to invoke <a class="el" href="group__nlmsg.html#gaead09f5a9430a226b1ca86ad1f36d316">mnl_nlmsg_put_header()</a> before you call this function. This function returns a pointer to the extra header. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00101">101</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="gaead09f5a9430a226b1ca86ad1f36d316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead09f5a9430a226b1ca86ad1f36d316">&#9670;&nbsp;</a></span>mnl_nlmsg_put_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a>* mnl_nlmsg_put_header </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_put_header - reserve and prepare room for Netlink header </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>memory already allocated to store the Netlink header</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets to zero the room that is required to put the Netlink header in the memory buffer passed as parameter. This function also initializes the nlmsg_len field to the size of the Netlink header. This function returns a pointer to the Netlink header structure. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00080">80</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="ga2c95a2455127da992641de0679dbab46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c95a2455127da992641de0679dbab46">&#9670;&nbsp;</a></span>mnl_nlmsg_seq_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL bool mnl_nlmsg_seq_ok </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnlmsghdr.html">nlmsghdr</a> *&#160;</td>
          <td class="paramname"><em>nlh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_seq_ok - perform sequence tracking </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlh</td><td>current netlink message that we are handling </td></tr>
    <tr><td class="paramname">seq</td><td>last sequence number used to send a message</td></tr>
  </table>
  </dd>
</dl>
<p>This functions returns true if the sequence tracking is fulfilled, otherwise false is returned. We skip the tracking for netlink messages whose sequence number is zero since it is usually reserved for event-based kernel notifications. On the other hand, if seq is set but the message sequence number is not set (i.e. this is an event message coming from kernel-space), then we also skip the tracking. This approach is good if we use the same socket to send commands to kernel-space (that we want to track) and to listen to events (that we do not track). </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00206">206</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
<a id="gaa6cdcdd6af1bab1ec4031faf97b18af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6cdcdd6af1bab1ec4031faf97b18af7">&#9670;&nbsp;</a></span>mnl_nlmsg_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL size_t mnl_nlmsg_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_nlmsg_size - calculate the size of Netlink message (without alignment) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>length of the Netlink payload</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the size of a netlink message (header plus payload) without alignment. </p>

<p class="definition">Definition at line <a class="el" href="nlmsg_8c_source.html#l00054">54</a> of file <a class="el" href="nlmsg_8c_source.html">nlmsg.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
