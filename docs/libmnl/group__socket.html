<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmnl: Netlink socket helpers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmnl
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Netlink socket helpers</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7cb1b776bc74317dd923b902028feaa3"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga7cb1b776bc74317dd923b902028feaa3">mnl_socket_get_fd</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl)</td></tr>
<tr class="separator:ga7cb1b776bc74317dd923b902028feaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765140d13a24af0818e5bc8443c9afac"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga765140d13a24af0818e5bc8443c9afac">mnl_socket_get_portid</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl)</td></tr>
<tr class="separator:ga765140d13a24af0818e5bc8443c9afac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42882c0136d45b99e743fedbdcfdae9b"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open</a> (int bus)</td></tr>
<tr class="separator:ga42882c0136d45b99e743fedbdcfdae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4023e622b7bb0d7b74aae04d855c7a"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gabe4023e622b7bb0d7b74aae04d855c7a">mnl_socket_open2</a> (int bus, int flags)</td></tr>
<tr class="separator:gabe4023e622b7bb0d7b74aae04d855c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18acb96d4993668e8e43ec09b38376ec"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga18acb96d4993668e8e43ec09b38376ec">mnl_socket_fdopen</a> (int fd)</td></tr>
<tr class="separator:ga18acb96d4993668e8e43ec09b38376ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed0897354a35f906bafeed808bf9d9c"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga3ed0897354a35f906bafeed808bf9d9c">mnl_socket_bind</a> (struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl, unsigned int groups, pid_t pid)</td></tr>
<tr class="separator:ga3ed0897354a35f906bafeed808bf9d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c236ac5ffa5c80dd69ea2a2b7be2bdc"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga7c236ac5ffa5c80dd69ea2a2b7be2bdc">mnl_socket_sendto</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl, const void *buf, size_t len)</td></tr>
<tr class="separator:ga7c236ac5ffa5c80dd69ea2a2b7be2bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847913b15141fd5c1b62cbe6f629ed8c"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga847913b15141fd5c1b62cbe6f629ed8c">mnl_socket_recvfrom</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl, void *buf, size_t bufsiz)</td></tr>
<tr class="separator:ga847913b15141fd5c1b62cbe6f629ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a632d13d34940e6595f41b2ae72c509"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga0a632d13d34940e6595f41b2ae72c509">mnl_socket_close</a> (struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl)</td></tr>
<tr class="separator:ga0a632d13d34940e6595f41b2ae72c509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf174c882ab437449d0513edf9dc27533"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gaf174c882ab437449d0513edf9dc27533">mnl_socket_setsockopt</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl, int type, void *buf, socklen_t len)</td></tr>
<tr class="separator:gaf174c882ab437449d0513edf9dc27533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74d8d8d89256529c9bbfcb47e0a24de"><td class="memItemLeft" align="right" valign="top">EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gab74d8d8d89256529c9bbfcb47e0a24de">mnl_socket_getsockopt</a> (const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *nl, int type, void *buf, socklen_t *len)</td></tr>
<tr class="separator:gab74d8d8d89256529c9bbfcb47e0a24de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3ed0897354a35f906bafeed808bf9d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed0897354a35f906bafeed808bf9d9c">&#9670;&nbsp;</a></span>mnl_socket_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL int mnl_socket_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_bind - bind netlink socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a> </td></tr>
    <tr><td class="paramname">groups</td><td>the group of message you're interested in </td></tr>
    <tr><td class="paramname">pid</td><td>the port ID you want to use (use zero for automatic selection)</td></tr>
  </table>
  </dd>
</dl>
<p>On error, this function returns -1 and errno is appropriately set. On success, 0 is returned. You can use MNL_SOCKET_AUTOPID which is 0 for automatic port ID selection. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00193">193</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga0a632d13d34940e6595f41b2ae72c509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a632d13d34940e6595f41b2ae72c509">&#9670;&nbsp;</a></span>mnl_socket_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL int mnl_socket_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_close - close a given netlink socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a></td></tr>
  </table>
  </dd>
</dl>
<p>On error, this function returns -1 and errno is appropriately set. On success, it returns 0. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00296">296</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga18acb96d4993668e8e43ec09b38376ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18acb96d4993668e8e43ec09b38376ec">&#9670;&nbsp;</a></span>mnl_socket_fdopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a>* mnl_socket_fdopen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_fdopen - associates a <a class="el" href="structmnl__socket.html">mnl_socket</a> object with pre-existing socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>pre-existing socket descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>On error, it returns NULL and errno is appropriately set. Otherwise, it returns a valid pointer to the <a class="el" href="structmnl__socket.html">mnl_socket</a> structure. It also sets the portID if the socket fd is already bound and it is AF_NETLINK.</p>
<p>Note that <a class="el" href="group__socket.html#ga765140d13a24af0818e5bc8443c9afac">mnl_socket_get_portid()</a> returns 0 if this function is used with non-netlink socket. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00161">161</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga7cb1b776bc74317dd923b902028feaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb1b776bc74317dd923b902028feaa3">&#9670;&nbsp;</a></span>mnl_socket_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL int mnl_socket_get_fd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_get_fd - obtain file descriptor from netlink socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the file descriptor of a given netlink socket. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00085">85</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga765140d13a24af0818e5bc8443c9afac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765140d13a24af0818e5bc8443c9afac">&#9670;&nbsp;</a></span>mnl_socket_get_portid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL unsigned int mnl_socket_get_portid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_get_portid - obtain Netlink PortID from netlink socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Netlink PortID of a given netlink socket. It's a common mistake to assume that this PortID equals the process ID which is not always true. This is the case if you open more than one socket that is binded to the same Netlink subsystem from the same process. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00099">99</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="gab74d8d8d89256529c9bbfcb47e0a24de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab74d8d8d89256529c9bbfcb47e0a24de">&#9670;&nbsp;</a></span>mnl_socket_getsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL int mnl_socket_getsockopt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_getsockopt - get a Netlink socket option </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a> </td></tr>
    <tr><td class="paramname">type</td><td>type of Netlink socket options </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer to store the value of this option </td></tr>
    <tr><td class="paramname">len</td><td>size of the information written in the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>On error, this function returns -1 and errno is appropriately set. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00343">343</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga42882c0136d45b99e743fedbdcfdae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42882c0136d45b99e743fedbdcfdae9b">&#9670;&nbsp;</a></span>mnl_socket_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a>* mnl_socket_open </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_open - open a netlink socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>the netlink socket bus ID (see NETLINK_* constants)</td></tr>
  </table>
  </dd>
</dl>
<p>On error, it returns NULL and errno is appropriately set. Otherwise, it returns a valid pointer to the <a class="el" href="structmnl__socket.html">mnl_socket</a> structure. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00128">128</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="gabe4023e622b7bb0d7b74aae04d855c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4023e622b7bb0d7b74aae04d855c7a">&#9670;&nbsp;</a></span>mnl_socket_open2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL struct <a class="el" href="structmnl__socket.html">mnl_socket</a>* mnl_socket_open2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_open2 - open a netlink socket with appropriate flags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>the netlink socket bus ID (see NETLINK_* constants) </td></tr>
    <tr><td class="paramname">flags</td><td>the netlink socket flags (see SOCK_* constants in socket(2))</td></tr>
  </table>
  </dd>
</dl>
<p>This is similar to <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a>, but allows to set flags like SOCK_CLOEXEC at socket creation time (useful for multi-threaded programs performing exec calls).</p>
<p>On error, it returns NULL and errno is appropriately set. Otherwise, it returns a valid pointer to the <a class="el" href="structmnl__socket.html">mnl_socket</a> structure. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00145">145</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga847913b15141fd5c1b62cbe6f629ed8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847913b15141fd5c1b62cbe6f629ed8c">&#9670;&nbsp;</a></span>mnl_socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL ssize_t mnl_socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsiz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_recvfrom - receive a netlink message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a> </td></tr>
    <tr><td class="paramname">buf</td><td>buffer that you want to use to store the netlink message </td></tr>
    <tr><td class="paramname">bufsiz</td><td>size of the buffer passed to store the netlink message</td></tr>
  </table>
  </dd>
</dl>
<p>On error, it returns -1 and errno is appropriately set. If errno is set to ENOSPC, it means that the buffer that you have passed to store the netlink message is too small, so you have received a truncated message. To avoid this, you have to allocate a buffer of MNL_SOCKET_BUFFER_SIZE (which is 8KB, see <a class="el" href="netlink_8h_source.html">linux/netlink.h</a> for more information). Using this buffer size ensures that your buffer is big enough to store the netlink message without truncating it. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00256">256</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="ga7c236ac5ffa5c80dd69ea2a2b7be2bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c236ac5ffa5c80dd69ea2a2b7be2bdc">&#9670;&nbsp;</a></span>mnl_socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL ssize_t mnl_socket_sendto </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_sendto - send a netlink message of a certain size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a> </td></tr>
    <tr><td class="paramname">buf</td><td>buffer containing the netlink message to be sent </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes in the buffer that you want to send</td></tr>
  </table>
  </dd>
</dl>
<p>On error, it returns -1 and errno is appropriately set. Otherwise, it returns the number of bytes sent. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00232">232</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
<a id="gaf174c882ab437449d0513edf9dc27533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf174c882ab437449d0513edf9dc27533">&#9670;&nbsp;</a></span>mnl_socket_setsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL int mnl_socket_setsockopt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmnl__socket.html">mnl_socket</a> *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mnl_socket_setsockopt - set Netlink socket option </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>netlink socket obtained via <a class="el" href="group__socket.html#ga42882c0136d45b99e743fedbdcfdae9b">mnl_socket_open()</a> </td></tr>
    <tr><td class="paramname">type</td><td>type of Netlink socket options </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer that contains the data about this option </td></tr>
    <tr><td class="paramname">len</td><td>the size of the buffer passed</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows you to set some Netlink socket option. As of writing this (see <a class="el" href="netlink_8h_source.html">linux/netlink.h</a>), the existing options are:</p>
<ul>
<li>#define NETLINK_ADD_MEMBERSHIP 1</li>
<li>#define NETLINK_DROP_MEMBERSHIP 2</li>
<li>#define NETLINK_PKTINFO 3</li>
<li>#define NETLINK_BROADCAST_ERROR 4</li>
<li>#define NETLINK_NO_ENOBUFS 5</li>
</ul>
<p>In the early days, Netlink only supported 32 groups expressed in a 32-bits mask. However, since 2.6.14, Netlink may have up to 2^32 multicast groups but you have to use setsockopt() with NETLINK_ADD_MEMBERSHIP to join a given multicast group. This function internally calls setsockopt() to join a given netlink multicast group. You can still use mnl_bind() and the 32-bit mask to join a set of Netlink multicast groups.</p>
<p>On error, this function returns -1 and errno is appropriately set. </p>

<p class="definition">Definition at line <a class="el" href="socket_8c_source.html#l00328">328</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
